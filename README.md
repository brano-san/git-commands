# Основные Git команды
## Общее
### Теги
Тег - метка для одного определенного коммита, через которую можно обращаться к коммиту, на который она указывает. Существуют двух видов:
  + Легковесный - указатель на определенный коммит, который является новым именем для коммита 
  + Аннотированный - хранится в git, как полноценный объект, содержит в себе имя автора, его почту, дату создание, сообщение, контрольную сумму, может быть подписан
### git rerere
Git rerere («reuse recorded resolution», повторно использовать сохранённое решение) - неявная функциональность git, которая позволяет git запоминать некоторые варианты разрешения конфликтов и в будущем решать похожие конфликты автоматически. Для включения функции необходимо выполнить команду:
```Bash
git config --global rerere.enabled true # Включить функцию rerere для всех проектов пользователя
```
Или вставить соответсвующие строки в файл конфигурации самостоятельно:
```Bash
# bash
git config --global --edit # Открыть глобальный файл конфигурации в текстовом редакторе
# Файл конфигурации
[rerere]
  enabled = true
```

### Спецификация ссылок
+refs/heads/\*:refs/remotes/origin/\* - информация для гит откуда брать ссылки и куда их сохранять
1. refs/heads/* - указывает откуда брать ссылки с удаленного сервера
2. refs/remotes/origin/* - указывает куда их записывать
3. '+' - говорит о необходимости обновления ссылок, даже если это не просто смещения
```Bash
# Пример использования спецификации ссылок для удаленного репозитория origin
[remote "origin"]
  url = https://github.com/brano-san/git-commands
  fetch = +refs/heads/*:refs/remotes/origin/* # Берем все ссылки refs/heads/ удаленного репозитория и отправить их в refs/remotes/origin/ локального репозитория
  push = refs/heads/master:refs/heads/master # Берем ссылку refs/heads/master локального репозитория и отправляем ее в refs/heads/master удаленного репозитория
```

### Диапазоны
Git предоставляет удобную функцию для работы с диапазонами коммитов (подразумевается некоторое множество коммитов). Существует два вида диапазонов:
  + Две точки (master..fix)  - все коммиты, которые есть в fix, но недостижимы из master  
  + Три точки (master...fix) - все коммиты, которые есть и в fix, и в master, но недостижимы из двух веток сразу
```Bash
A - B - C - D - G # <- master
          \      
            E - F # <- fix
```
```Bash
git log master..fix  # Выведет коммиты F, E
git log master...fix # Выведет коммиты G, D, F, E
```

### Pathspec
Pathspec - регулярное выражение, которое используется для передачи путей командам git. Позволяет ограничивать действия команд определенными файлами или каталогами. Поддерживает "магические слова":
+ ```:(top)``` или ```:/``` - соответствует корню git репозитория
+ ```:(exclude)``` или ```:!``` или ```:^``` - исключить указанный далее паттерн из возможных вариантов
+ ```:(icase)``` - игнорировать регистр
```Bash
git add '*.cpp' # Добавить в индекс все файлы с расширением .cpp
git add ':/*.cpp' # Добавить все файлы с расширением .cpp, начиная поиск с корневого каталога репозитория
git add ':/*.txt' ':!*doc.txt' # Добавить все файлы с расширением .txt, игнорировать файлы соответствующие *doc.txt
git add ':(icase)*.cpp' # Добавить все файлы с расширением .cpp, не зависимо от регистра
```

### Fast-forward
Fast-forward - стратегия слияния, которая подразумевает простое перемещение указателя вперед.
Например:
```Bash
A - B - C # <- master
          \
            D - E - F # <- fix
```
После выполнения команды ```git merge fix``` история приобретет следующий вид:
```Bash
A - B - C - D - E - F # <- master, fix
```

### Суффиксы указателей
+ HEAD\~n - линейно идет по истории на n шагов
+ HEAD\^n - выбирает n родителя текущего коммита
```Bash
A - B - C  -  D  -  G # <- HEAD
          \       /
            E - F
```
```Bash
git show HEAD~1 # Вернет D
git show HEAD~2 # Вернет C
git show HEAD^1 # Вернет D
git show HEAD^2 # Вернет F
```

### Специальные файлы git
+ ```.gitignore```  - указывает гиту какие файлы игнорировать при работе с репозиторием. Поддерживает шаблоны, похожие на регулярные выражения
+ ```.gitmodules``` - указывает гиту как работать с подмодулями. Схож с файлом конфигурации
+ ```.gitattributes``` - указывает гиту как работать с конкретными файлами. Например, можно указать, что .png файлы должны обрабатываться как двоичные, или строго указать тип EOL для всех файлов

## Пользовательские команды git (Porcelain Commands)
### ```git help``` - Получение справочной информации
```Bash
git help # Показать список команд пользоветельского уровня с их описанием
git help -a # Показать список всех команд с их описанием, а также созданные алиасы
git help -c # Показать все возможные переменные конфигурации 
git help commit # Показать документацию по команде git commit
```

### ```git config``` - Изменение параметров конфигурации репозиториев
```Bash
git config core.editor # Показать значение переменной core.editor
git config -l --show-scope # Показать все измененные переменные конфигурации и из область определения
git config --system --edit # Открыть в редакторе системный файл конфигурации
git config --global --edit # Открыть в редакторе глобальный файл конфигурации
git config --local --edit # Открыть в редакторе локальный файл конфигурации
git config --global user.name name # Установить имя пользователя name в глобальном файле конфигурации
git config --global alias.с 'commit' # Создать псевдоним команды git commit с именем c (git c)
git config --local core.editor vi # Установить vim текстовый редактор по умолчанию для конкретного проекта
git config --local --unset core.editor # Удалить значение core.editor из локального файла конфигурации
git config -f '.gitmodules' submodules.module.master origin/master # Установить новое значение в файле .gitmodules
```

### ```git init``` - Инициализация git-репозитория
```Bash
git init # Иницаилизировать git-репозиторий, создает папку .git в директории
git init --bare # Чистая инициализация, создает файлы из папки .git прямо в директории, используется на серверах
git init C://folder/to/repository/ # Инициализировать git-репозиторий по заданному пути
git init -b branch-name # Инициализировать git-репозиторий c начальной веткой branch-name
```

### ```git add``` - Добавление файлов в индекс
```Bash
git add . # Добавить все файлы из рабочей директории, которые не игнорируются, в индекс
git add -A # Аналог предыдущей команды
git add file-name # Добавить указанный файл в индекс
git add --dry-run (-n) . # Показать, что будет добавлено, но не выполнять добавление в индекс
git add --verbose (-v) . # Выполнить команду git add и покажет, что было добавлено
git add --interactive (-i) # Запустить интерактивный режим команды git add
git add --patch (-p) # Внести изменения в индекс частично, спрашивая об изменениях пользователя
git add --edit (-e) # Открыть в текстовом редакторе изменения, которые будут внесены в индекс, для редактирования
```

### ```git rm``` - Удаление файлов
```Bash
git rm path/to/file # Удалить файл из индекса и рабочей директории, фиксирует удаление в индекс
git rm --ignore-unmatch path/to/file # Не выводить сообщение о том, что не было найдено заданных файлов
git rm --cached file-name # Удалить файл из индекса
```

### ```git mv``` - Перемещение/Переименование файлов
```Bash
git mv file-name new-file-name # Переименовать файл и зафиксировать изменение в индексе
git mv file-name new/path/to/file # Переместить файл в другую директорию
```

### ```git commit``` - Создание коммитов
```Bash
git commit # Зафиксировать изменения из индекса в коммит, открывая текстовый редактор для изменения сообщения коммита
git commit -m "messege" # Зафиксировать изменения из индекса в коммит с заданным сообщением коммита
git commit -m "`date +'%X %x'`" # Зафиксировать изменения в коммит с сообщением, содержащим дату на данный момент
git commit -a # Добавить в индекс ТОЛЬКО отслеживаемые файлы, затем выполнить коммит
git commit --amend # Внести изменния в предыдущий коммит, открывая редактор сообщения коммита
git commit --amend --no-edit # Внести изменния в предыдущий коммит без изменения сообщения коммита
git commit --no-verify # Зафиксировать изменения из индекса в коммит без запуска хуков
git commit -s # Подписать коммит (может подтверждать, что коммитер имеет право работать под лицензией проекта)
git commit -S # Подписать коммит gpg-ключом
```

### ```git log``` - История коммитов репозитория
```Bash
git log # Показать историю коммитов
git log file-name # Показать все коммиты, в которых менялся указанный файл
git log -10 # Показать последние 10 коммитов
git log --merges (--no-merges) # Показать только коммиты слияния (Показать все коммиты кроме коммитов слияния)
git log -g # Добавить к истории коммитов информацию из reflog
git log -p # Добавить к истории коммитов изменения из каждого коммита
git log --submodule # Показать изменения подмодулей
git log --stat # Показать какие файлы и сколько строк было изменено
git log --left-right # Показать с какой "стороны" коммит, используется для диапазонов
git log --pretty=oneline # Показать все коммиты в одну строку
git log --pretty=format:"%C(bold blue)%h" # Показать только хеш коммитов синего цвета (можно настраивать)
git log --decorate=full # Показать полное имя ссылок
git log --abbrev-commit # Сократить SHA-1 хеш коммитов
git log --graph # Показать историю коммитов с графическим представлением ветвления
git log --grep update # Показать коммиты с описанием, содержащим слово 'update' с учетом регистра
git log -i --grep update # Показать коммиты с описанием, содержащим слово 'update' без учета регистра
git log -L'regex' # Показать только те коммиты, в которых менялись строки в соответствии с regex
git log --since='3 weeks' # Показать все коммиты за последние 3 недели
git log --before='2 days' # Показать все коммиты, не включая коммиты за последние 2 дня
git log --after='2023-10-10' # Показать все коммиты, сделанные после указанной даты
git log --author='author-name' # Показать все коммиты, которые сделала author-name
```

### ```git shortlog``` - Короткая история коммитов всех авторов репозитория
```Bash
git shortlog # Показать историю коммитов, сгруппированную по авторам и названиям
git shortlog --not master # Показать историю коммитов, невходящие в ветку master, сгруппированную по авторам и названиям
git shortlog --since='1 day' # Показать историю коммитов за последний день, сгруппированную по авторам и названиям
```

### ```git show``` - Подробная информация о коммите
```Bash
git show # Показать последний коммит с изменениями
git show master^ # Показать предпоследний коммит с изменениями
git show --format=oneline HEAD # Показать коммит в указанном формате
git show --pretty=format:"%C(bold blue)%h" HEAD # Показать коммит в указанном формате (вывести только хеш коммита)
git show :/"update" # Показать самый новый коммит в сообщении которого есть слово 'update'
git show master^:file-name # Показать содержимое file-name из коммита master~1
git show --name-only # Показать только файлы, в которых были изменения
```

### ```git show-branch``` - Ветки и их коммиты
```Bash
git show-branch # Показать ветки и их коммиты
git show-branch -g # Заменить ссылки веток на ссылки reflog
git show-branch -r # Показать удаленные ветки и их коммиты
git show-branch --all # Показать и локальные, и удаленные ветки, а также их коммиты
git show-branch --more=10 branch-name # Показать 10 коммитов, достижимых из ветки branch-name
```

### ```git reflog``` - История действий с указателями
```Bash
git reflog # Показать историю действий с указателем HEAD (alias на git log -g --abbrev-commit --pretty=oneline)
git reflog show # То же самое, что и предыдущая команда
git reflog stash # Показать reflog для спрятанных изменений
git reflog expire --expire=30.days.ago --all # ОПАСНО: Очищает историю с указанного времени
git reflog delete HEAD@{1} # ОПАСНО: Удаляет указанную запись в истории  
```

### ```git grep``` - Поиск файлов по содержимому
```Bash
git grep hello # Показать все вхождения слова hello во всех файлах рабочей директории
git grep 'text to find' # Показать в каких файлах содержится данная строка, не игнорировать регистр
git grep -i 'text' # Показать в каких файлах содержится данная строка, игнорировать регист
git grep -e 'void foo()' # Показать все вхождения 'void foo()'
git grep -e 'void foo()' (--or) -e 'void func()' # Показать все вхождения 'void foo()' ИЛИ 'void func()'
git grep -e 'void foo()' --and -e 'void func()' # Показать все вхождения 'void foo()' И 'void func()' (на одной строке)
git grep hello -- '*.cpp' # Выполнить поиск вхождений слова hello только в .cpp файлах
git grep hello -- :^file # Выполнить поиск вхождений слова hello во всех файлах за исключением file
git grep -n hello # Показать в каких файлах и на какой строке содержится слово hello
git grep -p hello # Дополнить вывод контекстом (например, сигнатурой функции)
git grep -с hello # Показать количество вхождений вместо отображения каждого
git grep --cached hello # Выполнить поиск слова hello в файлах из индекса
git grep --untracked hello # Выполнить поиск слова hello в рабочей директории и в неотслеживаемых файлах
```

### ```git diff``` - Просмотр разницы файлов
```Bash
git diff # Показать разницу между рабочей директорией и индексом 
git diff --staged # Показать разницу между индексом и последним коммитом
git diff HEAD # Показать разницу между рабочей директорией и последним коммитом
git diff HEAD~ HEAD # Показать разницу между предпоследним и последним коммитов
git diff path/to/file # Показать разницу между рабочей директорией и индексом заданного файла
git diff --submodule=log # Показать разницу в подмодулях
git diff --name-only # Показать только имена файлов, в которых были сделаны изменения
git diff --base # Показать разницу рабочей директории с базой слияния
git diff --ours # Показать разницу рабочей директории с 'нашей' веткой
git diff --theirs # Показать разницу рабочей директории с 'их' веткой
git diff master branch-name # Показать разницу двух веток
git diff branch-name...master # Показать изменения master ветки с момента создания branch-name
git diff branch-name -- file # Показать разницу HEAD и branch-name только в file
git diff HEAD^:file HEAD:file # Показать разницу file из предыдущего и нынешнего коммитов
```

### ```git branch``` - Работа с ветками
```Bash
git branch (-v) # Показать все существующие ветки
git branch -l 'm*' # Показать все существующие ветки, подходящие под заданное регулярное выражение 'm*'
git branch --no-merged # Показать все ветки, которые не слиты с текущей веткой
git branch -r # Показать удаленные ветки
git branch -a # Показать и удаленные, и локальные ветки
git branch branch-name # Создать новую ветку с названием branch-name
git branch branch-name HEAD^ # Создать новую ветку на предыдущем коммите с названием branch-name
git branch -m master main # Переименовать ветку master в main
git branch -c master main # Создать ветку, которая будет равна master, с названием main
git branch -d branch-name # Удалить ветку branch-name
git branch branch-name --track origin/branch # Создать ветку и сделать ее веткой слежения за origin/branch
```

### ```git switch``` - Переключение веток
```Bash
git switch branch-name # Переключится на ветку branch-name
git switch -c branch-name # Создать ветку branch-name и переключиться на нее 
git switch -c branch-name HEAD^ # Создать ветку branch-name на предыдущем коммите и переключиться на нее 
git switch -c branch-name --track origin/branch # Создать ветку, сделать ее веткой слежения за origin/branch и перейти на нее
git switch --detach HEAD^ # Перейти на предыдущий коммит, индекс и рабочая директория будут как в указанном коммите
```

### ```git checkout``` - Переключение веток или восстановление файлов
```Bash
git checkout file # Перевести file в состояние из индекса
git checkout -p file # Аналог предыдущей команды, но с интерактивным выбором изменений
git checkout HEAD^ # Перейти на предыдущий коммит (detached head)
git checkout HEAD^ file # ОПАСНО: Перевести файл в состояние, в котором он был в предыдущем коммите 
git checkout -- '*.cpp' # Перевести все файлы, которые соответствуют регулярному выражению '*.cpp', в состояние из индекса
git checkout -b branch-name # Создать новую ветку branch-name от активного коммита и перейти на нее
git checkout -b branch-name HEAD^ # Создать новую ветку branch-name от предыдущего коммита и перейти на нее
git checkout --track origin/branch # Создать ветку branch, сделать ее веткой слежения за origin/branch и перейти на нее
git checkout -b branch-name --track origin/branch # Создать ветку branch-name, сделать ее веткой слежения за origin/branch и перейти на нее
git checkout --ours file # Перевести file в состоние из ветки, в которую мы сливаем
git checkout --theirs file # Перевести file в состоние из ветки, которую мы сливаем с нашей
git checkout --merge file # Перевести file в состоние как при обычном merge, с маркерами конфликтов
```

### ```git merge``` - Слияние веток
```Bash
git merge branch-name # Слить активную ветку с branch-name
git merge master branch-name # Слить branch-name в master
git merge --abort # Прервать процесс слияния и восстановить состояние репозитория до слияния
git merge --continue # Завершить слияние после устрания конфликтов
git merge --no-commit # Остановить процесс слияния перед созданием коммита
git merge --squash # Перевести рабочее дерево и индекс в состояние, как если бы произошло слияние, но не делать слияние
git merge --no-ff # Выполнить слияние без fast-forward (создать коммит слияния)
git merge --ff-only # Выполнить слияние только через fast-forward (выдаст ошибку при невозможности выполнения ff)
git merge --edit # Открыть редактор сообщения коммита слияния перед фиксацией изменений
git merge --signoff # Подписать коммит (см. git commit -s)
```

### ```git merge-base``` - Общий коммит двух веток
```Bash
git merge-base master branch-name # Показать SHA-1 хэш коммита основы слияния веток master и branch-name
```

### ```git rebase``` - Перемещение коммитов
```Bash
git rebase master # Переместить коммиты текущей ветки в конец ветки master
git rebase master fix # Переместить коммиты ветки fix в конец ветки master
git rebase --onto master fix hotfix # Переместить коммиты fix..hotfix в конец ветки master
git rebase --continue # Перейти к следующему шагу разрешения конфликтов слияния
git rebase --abort # Отменить rebase и вернуть рабочую директорию в исходный вид
git rebase --skip # Пропустить текущий коммит, вызвавший конфликты слияния
git rebase -i master # Интерактивный режим команды, позволяет изменять историю репозитория
git rebase --rebase-merges # Не игнорировать коммиты слияния
```

### ```git reset``` - Сброс указателя ветки и HEAD до другого состояния
```Bash
git reset # Очистить индекс от изменений (изменения останутся в рабочей директории)
git reset file # Убрать указанный файл из индекса (изменения останутся в рабочей директории)
git reset -p # Выбрать интерактивно, на какие изменения влиять
git reset HEAD^ # Переместить HEAD и указатель ветки на один коммит назад, перевести индекс в состояние предыдущего коммита
git reset --soft HEAD^ # Переместить HEAD и указатель ветки на один коммит назад, индекс и рабочию директорию не трогать
git reset --mixed HEAD^ # Переместить HEAD и указатель ветки на один коммит назад, перевести индекс в состояние предыдущего коммита
git reset --hard HEAD^ # ОПАСНО: Переместить HEAD и указатель ветки на один коммит назад, перевестииндекс и рабочию директорию в состояние предыдущего коммита
git reset --merge HEAD^ # Переместить HEAD и указатель ветки на один коммит назад, сбросить файлы, которые отличаются между HEAD^ и индексом, но оставить те, которые отличаются между индексом и рабочей директорией (только во время разрешения конфликта)
git reset --keep HEAD^ # То же что и --hard, но не даст выполнить команду, если есть непроиндексированные изменения
```

### ```git restore``` - Восстановление файлов
```Bash
git restore file # Восстановить файл из индекса
git restore -- '*.cpp' # Восстановить все файлы из индекса, которые соответствуют регулярному выражению '*.cpp'
git restore --staged file # Восстановить file в индексе до состояния последнего коммита
git restore --staged --worktree file # Восстановить file в индексе и рабочей директории до состояния последнего коммита
git restore --source HEAD^ file # Восстановить file из предыдущего коммита
git restore --patch file # Интерактивно выбрать изменения для восстанавления
```

### ```git tag``` - Работа с тегами
```Bash
git tag # Показать все теги в репозитории
git tag -n # Показать все теги и их сообщения
git tag -l 'v1.*' # Показать все теги, соответствующие регулярному выражению 'v1.*'
git tag name # Создать легковесный тег с именем name, указывающий на активный коммит
git tag name HEAD^ # Создать легковесный тег с именем name, указывающий на предыдущий коммит 
git tag -a name -m "message" # Создать аннотированный тег с именем name и сообщением message, указывающий на активный коммит
git tag -d name # Удалить тег с именем name
git tag -v name # Показать информацию о теге name
```

### ```git describe``` - Создание синонима имени коммита
```Bash
# Может использоваться для создания bash скриптов, например, автоматизированного создания тегов
git describe HEAD # Дает объекту (блобу, коммиту и тд) понятное человеку название на основании последнего тега
```

### ```git bisect``` - Поиск коммита, в котором была добавлена ошибка
```Bash
git bisect start # Начать двоичный поиск неисправного коммита
git bisect start HEAD HEAD~4 # Начать поиск, HEAD - bad, HEAD~4 - good
git bisect bad (HEAD) # Пометить текущий коммит как неисправный
git bisect good HEAD~4 # Пометить четвертый с конца коммит как исправный
git bisect skip # Пропустить текущий коммит (например, не может быть протестирован)
git bisect log # Показать статус уже отмеченных коммитов 
git bisect visualize # Открыть графический интерфейс для отображения оставшихся коммитов в поиске
git bisect run test-script # Запустить test-script, который может сказать об исправности коммита
git bisect reset # Завершить поиск и вернуть HEAD к изначальному состоянию
```

### ```git blame``` - Кто и когда менял строки файла
```Bash
git blame file # Показать когда и кем была изменена каждая строка файла
git blame -L 10,20 file # Показать когда и кем была изменена каждая строка файла с 10 по 20
git blame --date=short # Изменить формат вывода даты на short
git blame --since='1 day' a.txt # Показать символ ^ перед каждой строкой, которая была сделана раньше одного дня
```

### ```git cherry-pick``` - Копирование/Перенос коммитов
```Bash
git cherry-pick branch-name # Применить изменения коммита branch-name к активному коммиту
git cherry-pick -n branch-name # Применить изменения коммита branch-name к активному коммиту, но не делать коммит
git cherry-pick master~2..master # Применить изменения последних двух коммитов в ветке master к активному коммиту
git cherry-pick master fix # Применить изменения последних коммитов веток master и fix (то есть 2 коммита) к активному коммиту
git cherry-pick --continue # Продолжить выполнение команды после разрешения конфликтов слияния
git cherry-pick --skip # Пропустить текущий коммит во время разрешния конфликтов слияния
git cherry-pick --abort # Отменить выполнение команды с возвращением рабочей директории к исходному состоянию
```

### ```git revert``` - Отмена коммитов
```Bash
git revert HEAD^ # Создать коммит, который отменяет предыдущий коммит
git revert -n HEAD~3..HEAD # Отменить изменения последних трех коммитов и не создавать коммит
git revert --continue # Продолжить выполнение команды после разрешения конфликтов слияния
git revert --skip # Пропустить текущий коммит во время разрешния конфликтов слияния
git revert --abort # Отменить выполнение команды с возвращением рабочей директории к исходному состоянию
```

### ```git stash``` - Сохранение незакоммиченных изменений рабочей директории
```Bash
git stash # Сохранить незакомиченные изменения в индексе и рабочей директории в "тайник"
git stash push # Аналог предыдущей команде
git stash list # Показать список всех тайников в репозитории
git stash pop # Восстановить изменения в рабочую директорию из последнего тайника и удалить его
git stash pop --index # Восстановить изменения в рабочую директорию и индекс из последнего тайника и удалить его
git stash pop stash@{1} # Восстановить изменения в текущую директорию из предпоследнего тайника и удалить его
git stash apply # Восстановить изменения в текущую директорию из последнего тайника но не удалять его
git stash drop stash@{1} # Удалить предпоследний тайник
git stash show stash@{1} # Кратко показать изменения, которые хранятся в предпоследнем тайнике
git stash show -p # Показать изменния, которые хранятся в последнем тайнике
```

### ```git clone``` - Клонирование репозиториев
```Bash
git clone https://github.com/brano-san/git-commands.git # Клонировать репозиторий в одноименную директорию
git clone https://github.com/brano-san/git-commands.git . # Клонировать репозиторий в текущую директорию
git clone https://github.com/brano-san/git-commands.git folder-name # Клонировать репозиторий в директорию folder-name
git clone --recurse-submodules URL # Обновить все подмодули при клонировании
```

### ```git remote``` - Работа с удаленными репозиториями
```Bash
git remote # Показать имена всех удаленных репозиториев
git remote -v # Показать информацию о том, куда отправляет и откуда получает данные, каждый репозиторий
git remote add origin https://github.com/brano-san/git-commands.git # Добавить удаленный репозиторий с именем origin указывающий на URL
git remote add -f origin https://github.com/brano-san/git-commands.git # Аналог предыдущей команды с получением ссылок удаленного репозитория
git remote rename origin new-name # Переименовать удаленный репозиторий origin на new-name
git remote remove origin # Удалить удаленный репозиторий origin
git remote get-url origin # Показать ссылку на удаленный репозиторий origin
git remote show origin # Показать подробную информацию об удаленном репозитории origin
git remote update origin # Скачать все ссылки и удалить устаревшие из удаленного репозитория origin
git remote prune (--dry-run) origin # Удалить все устаревшие ссылки, которые связанные с origin
```

### ```git fetch``` - Получение изменений удаленных репозиториев
```Bash
# git fetch требует дальнейшего git merge (или rebase) origin/master, чтобы получить обновления в свою рабочую директорию
git fetch origin # Скачать ссылки (ветки или теги) из удаленного репозитория origin
git fetch --all # Скачать ссылки (ветки или теги) из всех удаленных репозиториев
git fetch --prune --all # Удалить устаревшие ссылки всех удаленных репозиториев
git fetch -t origin # Скачать все теги из удаленного репозитория origin
git fetch origin develop:master # Обновить ссылки локальной ветки master ссылками удаленной ветки devolop
```

### ```git pull``` - Получение и слияние изменений удаленных репозиториев
```Bash
git pull # Выполнить git fetch origin и git merge (или rebase) для активной ветки (если установлены ветки слежения)
git pull origin # Выполнить git fetch origin и git merge (или rebase)
git pull --all # Скачать и выполнить слияние для всех удаленных репозиториев
git pull origin master # Выполнить слияние удаленной ветки master в текущую ветку
git pull -r origin # Выполнить git rebase вместо git merge
git pull --recurse-submodules origin # Также обновить все подмодули
```

### ```git push``` - Отправка изменений на удаленный репозиторий
```Bash
git push # Отправить данные текущей ветки в upstream (если указан)
git push origin master # Отправить данные ветки master в удаленный репозиторий origin
git push -u origin master # Аналог предыдущей команды с сохранением ветки слежения (upstream)
git push -d origin deleted-branch # Удалить ветки deleted-branch в удаленном репозитории
git push origin :deleted-branch # Аналог предыдущей команды
git push --prune origin # Удалить все ветки в удаленном репозитории, которых больше нет в локальном
git push --tags # Отправить теги в удаленный репозиторий
git push --follow-tags # Отправить только аннотированные теги в удаленный репозиторий
git push --recurse-submodules=only # Отправить только изменения подмодулей (указывает поведение с подмодулями) 
```

### ```git submodule``` - Работа с подмодулями
```Bash
git submodule add URL # Добавить подмодуль по заданному URL
git submodule init # Проинициализировать подмодули по файлу .gitmodules (используется после git clone)
git submodule update --remote # Выполнить git pull для каждого подмодуля
git submodule update --recursive # Обновить подмодули в локальном репозитории рекурсивно для вложенных модулей (после git pull)
git submodule update --rebase # Обновить подмодули и перебазировать локальные изменения
git submodule sync # Синхронизировать ссылки подмодулей (полезно, если подмодуль переехал на новый URL)
git submodule foreach 'git stash' # Выполнить git stash для каждого подмодуля
```

### ```git filter-branch``` - Редактирование каждого коммита в истории репозитория
```Bash
# ОПАСНО: имеет много подводных камней, например, одна и та же команда может иметь разные результат на разных компьютерах, а также неправильно обрабатывает пробелы в названиях файлов
# Рекомендуется использовать python утилиту filter-repo вместо filter-branch
git filter-branch --tree-filter 'rm -f file' HEAD # Выполнить команду 'rm -f file' для каждого коммита в истории HEAD (все изменения будут отражены в новом дереве)
git filter-branch --index-filter 'rm -f file' HEAD # Аналог предыдущей команды, но быстрее, потому что не проверяется дерево, работа идет с индексом
git filter-branch --env-filter 'GIT_AUTHOR_EMAIL=email' HEAD # Изменить почту автора для каждого коммита на email (используется для влияния на элементы окружения, такие как, почта и имя автора)  
git filter-branch --msg-filter 'echo "filter"' HEAD~3..HEAD # Изменить сообщение последних трех коммитов на 'filter' (используется для редактирования сообщения коммитов)
```

### ```git clean``` - Очистка локального репозитория
```Bash
git clean # Удалить неотслеживаемые файлы из рабочей директории (файлы указанные в gitignore удалены не будут)
git clean -f # Аналог предыдущей команды, если не указана переменная конфигурации clean.requireForce
git clean -i # Интерактивый режим команды git clean
git clean --dry-run # Показать какие файлы будут удалены без выполнения удаления
```

### ```git fsck``` - Проверка файлов git на ошибки
```Bash
git fsck # Проверить валидность файлов в базе данных git
git fsck --full # Показать висячие или недостижимые ссылки
```

### ```git prune``` - Удаление висячих объектов
```Bash
git prune --expire now # ОПАСНО: Очистить висячие или недостижимые обьекты, которые старше, чем 'now'
git prune --dry-run # Показать, что будет очищено, но не удалять объекты
```

### ```git gc``` - Сборка мусора и оптимизация git базы данных
```Bash
git gc # Очистить ненужные файлы и оптимизировать файлы внутреннего хранилища git
git gc --aggressive # Более тщательная и долгая очистка
git gc --prune=now # ОПАСНО: Очистить висячие или недостижимые обьекты, которые старше, чем 'now'
```

### ```git archive``` - Создание архива с проектом
```Bash
git archive --format=zip master > archive.zip # Сохранить дерево коммита master в архив с именем archive.zip
git archive -o archive.zip master # Аналог предыдущей команде
git archive -o --prefix='project/' archive.zip master # Аналог предыдущей команды, но поместить все файлы в директорую project/ 
```

## Графические утилиты
### ```git gitk``` - Графический интерфейс для просмотра истории коммитов репозитория
```Bash
gitk # Вызвать графический интерфейс, предназначенный для просмотра истории коммитов и изменений в них
gitk master # Вызвать графический интерфейс, c отображением истории ветки master
gitk --all # Вызвать графический интерфейс, c отображением всей истории и всеми ссылками
gitk -- file # Вызвать графический интерфейс и показать только те коммиты, в которых менялся file
gitk --since='2 days' # Вызвать графический интерфейс и показать коммиты за последние два дня
```

### ```git gui``` - Графический интерфейс для создания коммитов
```Bash
git gui citool (git gui, git citool) # Вызвать графический интерфейс, предназначенный для выполнения команд git-commit, git-add, git-push
git citool --amend # Аналог предыдущей команде, но будет изменен последний коммит
git gui blame file # Вызвать графический интерфейс, для отображения команды 'git blame file'
git gui blame HEAD~3 file # Вызвать графический интерфейс, для отображения команды 'git blame file' из HEAD~3 коммита
git gui browser master # Вызвать графический интерфейс, для просмотра рабочего дерева master, с возможностью запустить 'git gui blame' через интерфейс
```

### ```git difftool (mergetool)``` - Графический интерфейс для просмотра изменений
```Bash
git difftool # Вызвать графический интерфейс, предназначенный для отображения изменений между индексом и последним коммитом
git mergetool # Аналог предыдущей команде, но используется для разрешения конфликтов слияния
git difftool --tool-help # Показать возможные варианты внешних программ для difftool
git difftool --tool=vimdiff # Запустить vimdiff как инструмент сравнения изменений
git difftool master^ master # Показать разницу двух последних коммитов ветки master
```

## Низкоуровневые команды (Plumbing Commands)
Cледующие команды являются "сантехническими" и не используются при обычной работе с гитом, примеры их использования лежат за пределами повседновной работы с проектами, например, в создании скриптов, которые будут помогать при работе с git-репозиторием. Далее приведены далеко не все низкоуровневые команды, а только те, которые могут быть использованы чаще всех остальных.

### ```git hash-object``` - Вычисление хеша файлов
```Bash
git hash-object file # Вычислить SHA-1 хэш file
git hash-object -w file # Вычислить SHA-1 хэш file и сохранить его в базу данных гит (не индекс)
git hash-object -w -t blob file # Вычислить SHA-1 хэш file и сохранить его в базу данных гит как blob
```

### ```git rev-parse``` - Просмотр хеша объекта
```Bash
git rev-parse HEAD # Вывести SHA-1 хеш коммита, на который указывает HEAD 
```

### ```git cat-file``` - Просмотр содержимого базы данных git
```Bash
git cat-file blob e8ed98f # Вывести содержимое блоба с хешем e8ed98f
git cat-file -t e8ed98f # Вывести тип объекта с хешем e8ed98f
git cat-file -p e8ed98f # Автоматически определить тип объекта и распечать содержимое
git cat-file -s e8ed98f # Вывести размер объекта с хешем e8ed98f
```

### ```git ls-tree``` - Просмотр содержимого деревьев
```Bash
git ls-tree c8751c9 # Вывести содержимое дерева с хешем c8751c9
git ls-tree -d c8751c9 # Вывести объекты, которые содержаться только в этом дереве
git ls-tree -r c8751c9 # Рекурсивно вывести содержимое вложенных деревьев
git ls-tree --name-only c8751c9 # Вывести только имена объектов дерева c8751c9 
git ls-tree --full-name c8751c9 # Вывести полный путь к файлам дерева c8751c9
```

### ```git ls-files``` - Просмотр файлов рабочей директории
```Bash
git ls-files # Вывести файлы рабочей директории
git ls-files -u # Вывести файлы, который находятся в конфликтном состоянии 
git ls-files -t # Вывести статус файлов (неотслеживается, изменене и тд)
git ls-files --full-name # Вывести полный путь к файлам
```

### ```git ls-remote``` - Просмотр ссылок на удаленные репозитории
```Bash
git ls-remote # Вывести все ссылки на удаленные репозитории
git ls-remote --heads # Вывести все ссылки на удаленные репозитории из директории refs/
git ls-remote --tags # Вывести все ссылки на удаленные репозитории из директории tags/
git ls-remote origin master # Вывести только ссылки на master из удаленного репозитория origin
git ls-remote origin 'v1.*' # Вывести только ссылки соответствующие 'v1.*' из удаленного репозитория origin
```

### ```git show-ref``` - Просмотр всех ссылок репозитория
```Bash
git show-ref # Вывести все ссылки, хранящиеся в refs/
git show-ref --abbrev # Вывести все ссылки в сокращенном формате, хранящиеся в refs/
```

### ```git symbolic-ref``` - Просмотр полного имени ссылок
```Bash
git symbolic-ref HEAD # Вывести полный путь ссылки HEAD
git symbolic-ref refs/tags/v1.0 HEAD # Создать ссылку с именем v1.0, указывающую на HEAD
git symbolic-ref --delete refs/tags/v1.0 # Удалить ссылку с именем v1.0
```

### ```git count-objects``` - Просмотр стастики файлов репозитория
```Bash
git count-objects # Вывести количество объектов и их общий размер
git count-objects -v # Вывести больше информации
git count-objects -v -H # Сделать формат вывода размера понятным человеку
```
